name: Share Updates to Telegram

on:
  push:
    branches:
      - main
  workflow_dispatch: # allows manual run from Actions tab

jobs:
  announce:
    name: Post Update Summary to Telegram
    runs-on: ubuntu-latest

    steps:
      # 1ï¸âƒ£ Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2ï¸âƒ£ Get the latest commit message and changed files
      - name: Get recent commit info
        id: commits
        shell: bash
        run: |
          set -euo pipefail
          message_file="$RUNNER_TEMP/commit_message.txt"
          diff_file="$RUNNER_TEMP/changed_files.txt"

          event_name="${GITHUB_EVENT_NAME}"
          event_path="${GITHUB_EVENT_PATH}"
          after_sha="${GITHUB_SHA}"

          if [ "$event_name" = "push" ] && command -v jq >/dev/null 2>&1; then
            before_sha=$(jq -r '.before' "$event_path")
            after_sha=$(jq -r '.after' "$event_path")

            # Collect changed files across the pushed range
            if [ -n "$before_sha" ] && [ "$before_sha" != "0000000000000000000000000000000000000000" ]; then
              git diff --name-only "$before_sha" "$after_sha" | sed '/^$/d' > "$diff_file" || true
            else
              # Initial push or unknown before; diff against empty tree
              git diff --name-only $(git hash-object -t tree /dev/null) "$after_sha" | sed '/^$/d' > "$diff_file" || true
            fi

            # Build a concise list of commit subjects from the event payload
            jq -r '.commits[].message | split("\n")[0] | select(length>0) | "- " + .' "$event_path" > "$message_file" || true
            if [ ! -s "$message_file" ]; then
              # Fallback: use git log subjects across the range
              if [ -n "$before_sha" ] && [ "$before_sha" != "0000000000000000000000000000000000000000" ]; then
                git log --format='- %s' "$before_sha..$after_sha" > "$message_file" || true
              else
                git log --format='- %s' "$after_sha" > "$message_file" || true
              fi
            fi
          else
            # workflow_dispatch or missing jq: use single-commit info
            git log -1 --pretty=format:%s%n%b "$after_sha" > "$message_file" || true
            git show --name-only --pretty="" "$after_sha" | sed '/^$/d' > "$diff_file" || true
          fi

          # Ensure files are not empty to avoid downstream surprises
          if [ ! -s "$message_file" ]; then
            printf "Update %s\n" "$after_sha" > "$message_file"
          fi
          if [ ! -s "$diff_file" ]; then
            printf "(no files detected)\n" > "$diff_file"
          fi

          # Expose output paths to later steps (small strings only)
          {
            echo "message_path=$message_file"
            echo "diff_path=$diff_file"
          } >> "$GITHUB_OUTPUT"

      # 3ï¸âƒ£ Generate AI-written summary via OpenAI (ChatGPT)
      - name: Generate summary with ChatGPT
        id: chatgpt
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail

          # Helper: build a sensible fallback summary from commit + changed files
          build_fallback() {
            local msg file songs_list="" unique_tmp="$RUNNER_TEMP/songs_uniq.txt"
            msg=$(cat "$RUNNER_TEMP/commit_message.txt" 2>/dev/null || true)
            : > "$unique_tmp"
            if grep -q '^public/songs/' "$RUNNER_TEMP/changed_files.txt" 2>/dev/null; then
              while IFS= read -r file; do
                case "$file" in
                  public/songs/*)
                    base=${file##public/songs/}
                    base=${base%.*}
                    # Replace separators with spaces for readability
                    base=${base//_/ }
                    base=${base//-/ }
                    echo "$base" >> "$unique_tmp" ;;
                esac
              done < "$RUNNER_TEMP/changed_files.txt"
              if [ -s "$unique_tmp" ]; then
                sort -u "$unique_tmp" > "$unique_tmp.sorted"
                songs_list=$(sed 's/^/- /' "$unique_tmp.sorted")
                printf "%s\n" "$songs_list"
                rm -f "$unique_tmp" "$unique_tmp.sorted" 2>/dev/null || true
                return 0
              fi
            fi
            # Default narrative using commit subject/body first line
            if [ -n "$msg" ]; then
              printf "%s\n" "$msg" | sed -n '1,4p'
            else
              printf "Updates and improvements to GraceChords.\n"
            fi
          }

          # If no API key is present, write fallback summary and skip API call
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "No OPENAI_API_KEY provided; using fallback summary." >&2
            build_fallback > "$RUNNER_TEMP/summary.txt"
            exit 0
          fi

          # Build JSON payload safely with jq to avoid quote escaping issues
          payload=$(jq -n \
            --rawfile message "$RUNNER_TEMP/commit_message.txt" \
            --rawfile diff "$RUNNER_TEMP/changed_files.txt" \
            '{
              model: "gpt-4o-mini",
              messages: [
                {
                  role: "system",
                  content: "You are the GraceChords Bot, a friendly and concise technical writer. For public Telegram updates, write either (1) a short narrative summary in 1â€“2 sentences, or (2) a simple bulleted list of songs and/or features added. No headings, no links, no hashtags. Use plain text only. Keep it under 100 words."
                },
                {
                  role: "user",
                  content: ("Commit messages:\n" + $message + "\n\nChanged files:\n" + $diff + "\n\nWrite either a brief public-friendly changelog summary OR a bulleted list of songs/features added. No links. No headings. Plain text only. Keep it under 100 words.")
                }
              ],
              max_tokens: 300,
              temperature: 0.7
            }')

          # Call OpenAI API
          response=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$payload" || true)

          # Extract message content from API response (if present)
          summary=$(echo "$response" | jq -er '.choices[0].message.content' 2>/dev/null || true)

          # Fallback summary if API failed or returned empty
          if [ -z "${summary:-}" ] || [ "$summary" = "null" ]; then
            summary=$(build_fallback)
          fi

          # Export for next step
          printf "%s" "$summary" > "$RUNNER_TEMP/summary.txt"

      # 4ï¸âƒ£ Send the formatted summary to Telegram (robust JSON, no brittle Markdown parsing)
      - name: Send update to Telegram
        shell: bash
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram secrets missing; skipping send." >&2
            exit 0
          fi

          # Load ChatGPT output from temp file (supports multiline)
          summary="$(cat "$RUNNER_TEMP/summary.txt" 2>/dev/null || true)"

          if [ -z "$summary" ] || [ "$summary" = "null" ]; then
            summary="(No summary generated â€” possibly empty commit message)"
          fi

          # Escape HTML special chars in summary for Telegram HTML parse mode
          safe_summary=$(printf '%s' "$summary" | sed -e 's/&/\\&amp;/g' -e 's/</\\&lt;/g' -e 's/>/\\&gt;/g')

          title='<b>ðŸŽ¸ GraceChords Update</b>'
          footer='<i><a href="https://www.gracechords.com/">Check it out!</a></i>'
          text="$title\n\n$safe_summary\n\n$footer"

          # Build JSON payload using jq to ensure correct escaping
          payload=$(jq -n \
            --arg chat_id "$TELEGRAM_CHAT_ID" \
            --arg text "$text" \
            --arg mode "HTML" \
            '{chat_id: $chat_id, text: $text, parse_mode: $mode, disable_web_page_preview: true}')

          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$payload"
